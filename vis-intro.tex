%\section{Introduction}

The previous chapters have showed our monitoring systems.
They can generate traces which contain valuable information on
the execution of the software.
The information include internal control flow of the program as well
as external interaction between the operating system and other programs.
However, the traces can be very large and also difficult to analyze.
We observed that an idle Windows system generates about 800K
events/hour using our WinResMon (Sec.~\ref{sec:winresmon}).
A busy system can generate more than 100M events/hour.
Statistics from \cite{verbowski6flight} also show that Windows
server workloads can generate as much as 70M events/day,
while an idle machine can generate about 1M events/day.
Although much of the interactions between the processes and software in the
system is contained in the trace, in practice, the detail
can be overwhelming.

One way to understand very large amount of data is through visualization,
which abstracts information into a graphical form so that it can be more
easily perceived by human.
In this chapter, we show two trace visualizations which visualizes
the traces generated by our WinResMon.
Throughout the chapter,
we work on two types of traces,
The {\em system trace} records the interaction among the operating system and
different software.
The {\em program trace} records the execution of a single program,
whose level of detail can be system call only as in WinResMon, or
instruction trace (Sec.~\ref{sec:instrumentation}).

Section~\ref{sec:depvis} shows our first visualization, which
investigates the dependencies between programs and binaries.
Software often lives in a complex software eco-system
with complex interactions and dependencies between different
modules or components.
As we have discussed in Section~\ref{sec:bg-win},
this problem is exacerbated both by the 
overall system complexity and its closed source nature in Windows.
Even when source is available, there are still interactions with
modules which are only in binary form.
The visualization uses system traces from WinResMon and
program traces from binary instruction,
thus it does not need to rely on source code.
We use the following scenarios to explain how our visualizations can
be used to investigate various aspects of software dependencies:
(i) visualizing whole system software dependencies;
(ii) visualizing the interactions between selected modules of some software;
(iii) discovering unexpected module interactions; 
and (iv) understanding the source of the modules being used.
Because of the large number of modules and their complex dependencies,
we developed a number of ``zooming in'' techniques including
grouping of modules;
filtering by causality; and
the ``diff'' of two dependencies.
The work has been published in \cite{wu2010comprehending}.

Section~\ref{sec:lviz} shows our second visualization, \code{lviz}, which
is a visualization tool for many different purposes including
software failure diagnostics,
analysing performance issues, anomaly discovery, etc.
The visualization is based on DotPlot, which compares two traces
and plot the common (or different) items.
It was early used for
analysing similarities in DNA sequences \cite{maizel1981enhanced}.
\code{lviz} extends the traditional DotPlot through a number of visual elements
so that we can easily associate the visual representation with events in the
trace and identify the key events.
As we will see in a number of case studies,
\code{lviz} is highly customizable can be used to look at problems
across a large spectrum.
The work has been published in \cite{wu2010visualizing}.
