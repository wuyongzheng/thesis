\section{Background and Related Work}

In this chapter, we give some background and related work on system monitoring.

\TODO{define system monitoring}

Related work can be classified in a number of ways.
From the enforcement point of view, we have discretionary and
mandatory monitoring.
Discretionary monitoring requires that the monitored software
actively report to its monitor.
The traditional UNIX \code{syslog} is an example of discretionary monitoring.
A log entry is generated when the monitored software calls \code{syslog(2)}.
The naive \code{printf()} debugging technique is also discretionary monitoring.
In contrast, mandatory monitoring systems enforce that logs entries are always
generated when certain actions are performed by the monitored software.
The \code{ptrace(2)} interface and Solaris Basic Security Module (BSM) Auditing
are examples of mandatory monitoring.
Mandatory monitoring is more suited for security purpose because of its enforcement.
Discretionary monitoring may give more friendly output since the monitored
software knows which pieces are more important.

A correlated classification is transparent/opaque monitoring.
In transparent monitoring, the monitored software does not need to be adapted
and sometimes is not aware of being monitored;
whereas in opaque monitoring, the monitored software need to be either
rewritten and recompiled or transformed manually.
The two types of classification are usually correlated because transparent monitoring
is usually mandatory as well, and opaque monitoring is usually discretionary.

 From execution environment point of view, the monitor can be executed
in a number of environments.
\begin{itemize}
\item The monitor can be executed in the process (i.e. same address)
of the monitored software.
The naive \code{printf()} debugging technique belong to this category.
A common technique to monitor API or DLL function calls is to rewrite
the to-be-monitored function with a wrapper function which does the
logging and then calls the actual function.
This type of monitor is usually used for debugging purpose, and not for
security, because the monitoring can be circumvented.
\item In order to prevent circumvention,
the monitor can be executed in the kernel (assuming the kernel is authentic).
The \code{strace} utility uses the kernel \code{ptrace(2)} interface
to monitor system calls.
Most of the related work that we are going to introduce are kernel based.
\item In the same vein, to securely monitor kernel events, the monitor
should execute in a lower level than the kernel, i.e. the hypervisor.
Examples are the virtual machine monitors.
The recent Intel and AMD processors support hardware virtualization
features which can virtualize and monitor unmodified kernel with almost
no performance penalty.
\item The {\em instrumentation} technique is used to get instruction
level monitoring.
There are a number of instrumentation methods.
The earliest one executes binary program in a similar way
like interpreted language which parses and evaluates the instructions.
Later ones, such as Pin and Valgrind, alters the instruction stream on-the-fly
and let the CPU execute the altered instruction stream.
Section~\ref{sec:instrumentation} will discuss this in detail.
\end{itemize}

Another classification is whether the monitoring system is able to
alter the execution of the monitored software.
Logging systems such as \code{syslog} only record the events,
but do not alter the execution (except perhaps performance overhead).
%Other logging systems include Solaris BSM and DTrace.
\code{ptrace(2)}, on the other hand, can be used to filter system calls
or change system call's arguments.

\begin{table}
\centering
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
system & enforce & transp. & level & alter & OS & section\\ \hline \hline
\code{printf} & disc. & opaque & user & log & all & \\ \hline
\code{syslog} & disc. & opaque & user & log & POSIX & \ref{sec:syslog} \\ \hline
\code{ptrace(2)} & mand. & transp. & kernel & alter & POSIX & \ref{sec:ptrace} \\ \hline
\code{/proc} & mand. & transp. & kernel & alter & Solaris & \ref{sec:ptrace}  \\ \hline
Linux audit & disc. & opaque & kernel & log & Linux & \ref{sec:laudit} \\ \hline
FileMon & \multirow{3}{*}{mand.} & \multirow{3}{*}{transp.} & \multirow{3}{*}{kernel} & \multirow{3}{*}{log} & \multirow{3}{*}{Windows} & \multirow{3}{*}{\ref{sec:sysinternals}} \\
RegMon & & & & & & \\
ProcMon & & & & & & \\ \hline
DTrace & both & opaque & kernel & log & Solaris & \ref{sec:dtrace} \\ \hline
DProbes & \multirow{2}{*}{both} & \multirow{2}{*}{opaque} & \multirow{2}{*}{kernel} & \multirow{2}{*}{log} & \multirow{2}{*}{Solaris} & \multirow{2}{*}{\ref{sec:systemtap}} \\
SystemTap & & & & & & \\ \hline
Pin & \multirow{2}{*}{mand.} & \multirow{2}{*}{transp.} & \multirow{2}{*}{instru.} & \multirow{2}{*}{alter} & \multirow{2}{*}{Lin, Win.} & \multirow{2}{*}{\ref{sec:instrumentation}} \\
DynamoRIO & & & & & & \\ \hline
valgrind & mand. & transp. & instru. & alter & Linux & \ref{sec:instrumentation} \\ \hline
\end{tabular}
\caption{Classification of Monitoring Systems}
\label{tab:mon-tax}
\end{table}

Before discussing each related work in detail, Table~\ref{tab:mon-tax}
lists the classification of them.

\subsection{Traditional \code{syslog}}
\label{sec:syslog}

Syslog is the main logging tool on a UNIX systems. It centrally manages logging
for your main system services. Syslog is discretionary in such a sense that it
requires the program to actively call the \code{syslog(2)} system call in order to
generate a log message. Syslog is implemented in two halves. One half is a set
of standard C-library routines. Programs utilize these routines to send
messages to the log daemon. The other is a daemon process \code{syslogd}. It is
configured with the \path{/etc/syslog.conf} file. It writes log messages to various
locations.

When writing kernel code, one can send log messages to \code{syslog} by calling
\code{printk}\footnote{\code{printk} is Linux kernel specific} kernel.  This is
realized through \code{klogd}, the kernel log daemon.  \code{klogd} is a system
daemon which intercepts and logs Linux kernel messages. It is usually
configured to forward kernel messages to \code{syslogd}. Traditional logging
mechanism such as \code{syslog} is discretionary in nature, thus cannot be used
for security purpose. In the security monitoring context, we should not trust
the monitored program, thus the log message supplied by it should also not be
trusted. For example, the application does not log or logs something to spoof
the monitor.

\subsection{\code{ptrace} and \code{/proc}}
\label{sec:ptrace}

A commonly used technique for monitoring is system call tracing or system call
interposition to monitor the system calls made by a process.
For portability, systems like Janus \cite{wagner1999janus} or Alcatraz \cite{liang2009alcatraz}
use the Unix user-level mechanisms \code{ptrace} or \code{/proc} to do
system call tracing.
This usage is problematic because it is not
meant to be a secure monitoring mechanism, e.g.
\code{ptrace} was meant to support debuggers.
In the Solaris manual pages, \code{ptrace} is described as being
``unique and arcane''.
These kinds of problems and common
pitfalls with user-level system call interposition
are discussed in \cite{garfinkel2003traps}, such as:
(i) race conditions between time of check and time of use (TOCTOU), 
i.e. a buffer can be modified by another thread;
(ii) non-inheritance of tracing, i.e. special \code{strace} hacks in Linux;
and (iii) not transparent with respect to setuid/setgid executables 
and signals,
i.e. \code{ptrace} and \code{/proc} disable tracing 
on setuid/setgid executables.  
One could write a simple C program as in Figure~\ref{fig:ptrace-bug}
to escape from ptraceing.
After several iterations, some
child processes will not be traced by the tracing program.
As well as \code{ptrace(2)}, \code{/proc}
brings side-effect to the traced process.
When a traced process calls \code{setuid(2)},
the call will fail because the tracing process would have insufficient
privileges to the setuided process.
Because of their subtleties and intrinsic difficulties,
\code{ptrace} and \code{/proc} are not suitable for general purpose user-level
monitoring although they may be useful in specific situations.

\begin{figure}[htb]
\begin{verbatim}
#include <sys/types.h>
#include <sys/times.h>
#include <unistd.h>
main()
{
  struct tms timing;
  int i;
  getpid();
  if (fork() == 0) {
    getppid();
    if (fork() == 0) {
      times(&timing);
      _exit(1);
    }
    for (i=0; i < 10; getpid()) ;
  }
}
\end{verbatim}
\caption{Simple C program to escape \code{ptrace}}
\label{fig:ptrace-bug}
\end{figure}

The other serious drawback of \code{ptrace} or \code{/proc} is that
the overhead is considerable, incurring at least two
context switches per traced system call.
Our micro benchmarks in \TODO{fill} show that this can lead to an order of magnitude
slowdown on system call intensive programs.

\subsection{Linux Auditing System}
\label{sec:laudit}

The Linux auditing system (also known as lightweight auditing framework)
is used to monitor kernel events such as system calls and file system
operations.
The system consists of the kernel space event record producer and
the user space event record consumer (i.e. the audit daemon \code{auditd}).
At compile time,
kernel developers insert audit code into the kernel.
At run time, system administrators control which event and what information
to record using the \code{auditctl} tool.
All event records are transmitted through netlink sockets to \code{auditd}.
The event records are stored in a custom database which can be queried
using the \code{ausearch} and \code{aureport} tools.
The auditing system is incorporated into Linux kernel since version 2.6.4,
and is available in almost all Linux distributions.

The auditing system is a discretionary monitoring system to the kernel because
monitoring code is manually inserted by the kernel developer and can
be circumvented by kernel code.
However, when used for monitoring system calls of a user program,
it can be considered as mandatory if the kernel is assumed to be authentic.
The system only performs logging and does not alter the execution,
thus buffering of event records can be used to reduce context switches
and improve performance.

\subsection{Windows Sysinternals}
\label{sec:sysinternals}

FileMon \cite{filemon} and RegMon \cite{regmon}
are file and registry monitoring tools for Windows, respectively.
They monitor operations taking place on
the registry or specified file system.
A graphical interface is used to filter and display monitored events in real time.
We have observed (details in Section \TODO{fill}) that both tools can drop events when the
events are fast generated.

\TODO{add procmon}

\subsection{Solaris DTrace}
\label{sec:dtrace}

DTrace\cite{cantrill2004dynamic} is a dynamic tracing framework
created on Solaris 10, for troubleshooting kernel and application problems
on production systems.
Software developers insert probes into the code of the software
(kernel or user space program) at compile time.
System administrators or users monitor the execution by writing
a script in the {\em D language} and associating them with the probes,
so that when the software executes over the probes, the script is executed.
There are currently 30,000 \TODO{recheck} probes\footnote{
Since both Solaris kernel and DTrace are in active development,
our information is based on its current status in June 2011.}
in almost all aspects of the kernel.
The D script runs in the kernel and thus reduces the context switch.
For example, to count the number of \code{write(2)} system call of a process,
an integer variable is declared and a script which increments it
is associated with the \code{syscall::write:entry} probe.
Only one context switch is needed to output the final count.
To do this using \code{ptrace(2)}, a pair of context switch is
needed for each \code{write(2)} system call.

Having monitoring code dynamically (That is where the D comes from)
generated at runtime and executed in kernel is the key feature of
DTrace.
This poses a security threat as well however.
To prevent D script from running into infinite loops,
loops (or backward branch in general) and user defined functions
are not supported.

\TODO{Should I this mention here:
However, our micro-benchmarks in Section~\ref{sec:lbox-bench}
indicate that while it is significantly
faster than \code{/proc}, we have observed a factor of 2x slowdown.}

\subsection{DProbes and SystemTap}
\label{sec:systemtap}
% http://sourceware.org/systemtap/wiki/SystemtapDtraceComparison

\subsection{Instrumentation tool: Pin, valgrind and DynamoRIO}
\label{sec:instrumentation}
